//------------------------------------------------------------------------------
// top.v generated by "gen_ahb_top.sh"
//------------------------------------------------------------------------------
`timescale 1ns/1ps
`ifndef CLK_FREQ
`define CLK_FREQ       100000000
`endif
`ifndef BUS_DELAY
`define BUS_DELAY
`endif
`ifndef MEM_DELAY
`define MEM_DELAY
`endif
`ifndef SIZE_IN_BYTES
`define SIZE_IN_BYTES 1024
`endif

module top_m2s1
   #( parameter INSTR_RDATA_WIDTH = 32,
      parameter RAM_ADDR_WIDTH = 22,
      parameter BOOT_ADDR  = 'h80);
      
   //---------------------------------------------------------------------------
   localparam CLK_PERIOD_HALF=1000000000/(`CLK_FREQ*2);
   reg         HCLK   = 1'b0; 
   reg         HRESETn= 1'b0; 
   
   always #(CLK_PERIOD_HALF) HCLK=~HCLK;
   initial #155 HRESETn=1'b1;

   reg  [31:0]          mem[0:1024*256-1];

   //---------------------------------------------------------------------------
   logic trap;

   // logic          trans_valid;
   // logic          trans_ready;
   // logic [31:0]   trans_addr;
   // logic          trans_we;
   // logic [3:0]    trans_be;
   // logic [31:0]   trans_wdata;
   // logic [5:0]    trans_atop;

   // logic          resp_valid;
   // logic [31:0]   resp_rdata;
   // logic          resp_err;  // Unused for now

   // logic          obi_req_o;
   // logic          obi_gnt_i;
   // logic [31:0]   obi_addr_o;
   // logic          obi_we_o;
   // logic [3:0]    obi_be_o;
   // logic [31:0]   obi_wdata_o;
   // logic [5:0]    obi_atop_o;   // Not (yet) defined in OBI 1.0 spec
   // logic [31:0]   obi_rdata_i;
   // logic          obi_rvalid_i;
   // logic          obi_err_i;     // External bus error (validity defined by obi_rvalid_i)



   wire           trace_valid;
   wire [35:0]    trace_data;
	reg [31:0]     irq = 0;


       // testbench result
   logic                   tests_passed;
   logic                   tests_failed;
   logic                   exit_valid;
   logic [31:0]            exit_value;

   // signals for ri5cy
   logic                   fetch_enable;

   // make the core start fetching instruction immediately
   assign fetch_enable = '1;
   //---------------------------------------------------------------------------

   cv32e40p_tb_wrapper #(
      .INSTR_RDATA_WIDTH (INSTR_RDATA_WIDTH),
      .RAM_ADDR_WIDTH    (RAM_ADDR_WIDTH),
      .BOOT_ADDR         (BOOT_ADDR)
   )
   cv32e40p_tb_wrapper_i(
      .clk_i          ( HCLK         ),
      .rst_ni         ( HRESETn      ),
      .fetch_enable_i ( fetch_enable ),
      .tests_passed_o ( tests_passed ),
      .tests_failed_o ( tests_failed ),
      .exit_valid_o   ( exit_valid   ),
      .exit_value_o   ( exit_value   )
   );
	
   //---------------------------------------------------------------------------
   initial begin
      `ifdef VCD
          // use +define+VCD in 'vlog'
          $dumpfile("wave.vcd");
          $dumpvars(0);
      `else
           // use +VCD in 'vsim'
           if ($test$plusargs("VCD")) begin
               $dumpfile("wave.vcd");
               $dumpvars(5);
           end
      `endif
   end
   //---------------------------------------------------------------------------
	integer trace_file;

	initial begin
		if ($test$plusargs("trace")) begin
			trace_file = $fopen("testbench.trace", "w");
			repeat (10) @(posedge HCLK);
			while (!trap) begin
				@(posedge HCLK);
				if (trace_valid)
					$fwrite(trace_file, "%x\n", trace_data);
			end
			$fclose(trace_file);
			$display("Finished writing testbench.trace.");
		end
	end

   // we either load the provided firmware or execute a small test program that
   // doesn't do more than an infinite loop with some I/O
   initial begin: load_prog
      automatic string firmware;
      automatic int prog_size = 6;

      if($value$plusargs("firmware=%s", firmware)) begin
          if($test$plusargs("verbose"))
              $display("[TESTBENCH] @ t=%0t: loading firmware %0s",
                       $time, firmware);
          $readmemh(firmware, mem);
      end else begin
          $display("No firmware specified");
          $finish;
      end
   end

   integer i;
   initial begin
      for(i = 0; i < 100+2;i=i+1) begin
         $display("mem[%0d] = %h", i, mem[i]);
      end
   end
   // we either load the provided firmware or execute a small test program that
   // doesn't do more than an infinite loop with some I/O
   // initial begin: load_prog_sub
   //    automatic string firmware;
   //    automatic int prog_size = 6;

   //    if($value$plusargs("firmware=%s", firmware)) begin
   //        if($test$plusargs("verbose"))
   //            $display("[TESTBENCH] @ t=%0t: loading firmware %0s",
   //                     $time, firmware);
   //        $readmemh(firmware, cv32e40p_tb_wrapper_i.u_sub_mem_ahb.mem);
   //    end else begin
   //        $display("No firmware specified");
   //        $finish;
   //    end
   // end

endmodule
